**学习目标：
1. 什么是反射？
2. 反射的作用，以及如何使用？
3. 反射有什么需要注意的地方？
4. 反射的好处和缺点
5. 反射的例子**

**1、什么是反射？反射的定义？**
Ans:回答这个问题需要和另一个东西进行对比，这样理解更快。
JVM在识别类的时候有两种方式，一种是RTTI（Run-Time Type Identification，运行时类型识别），另一种则是反射。RTTI要求我们在编程时知道相关类的方法和属性，编程逻辑清楚。而反射则允许我们在运行时才获取类型及其声明的属性和方法，可以分析类的能力。

**2、反射的作用，以及如何使用？**
检查累的结构！
(1)、在运行中分析类的能力（比如可以知道类有哪些属性，方法）
(2)、在运行中查看对象（通过类反射可以强行查看一个对象的属性，哪怕这些属性时private的，没有设置getter方法）
(3)、实现数组的操作代码（可以强行创建某一个类的数组并进行操作，只需要给一个Class或者一个字符串或者一个对象就可以）
(4)、利用Method对象（获取类里的方法）

**3、反射有什么需要注意的地方？**
我们至少要了解这么几个方法的作用以及区别。
(1)、class.newInstance()
(2)、getMethod(是否带declare有何区别)
(3)、getField
(4)、setAccess
(5)、method.invoke
第一个，class.newInstance()方法是做什么的？和直接new一个有什么区别？
Ans:class.newInstance可以用来创建对象。和new不同的是，class.newInstance()不需要知道类的名字，比如说我们有一个对象A，我们可以通过`Class class = A.getClass`获取到A的类型，然后通过`class.newInstance()`创建出一个A的类型的对象，甚至先可以通过`Class class = Class.forName("类名")`获取到类，在通过newInstance创建对象，在这里forName方法里面只需要一个字符串就可以了,我们可以自己定义这个字符串，是不是很神奇。而new关键字只能在我们知道类型的条件下才能使用。(但是最近在使用的过程中，发现newInstance在java9以后被废弃了)

第二个，getMethod。
Ans:该方法返回一个`Method`对象，这个方法需要两个参数，`String name`代表方法的名称，`Class<?>... parameterTypes`代表一个装满了这个方法所有参数的参数类型的数组。和declare不同，这个方法只能获取到公共方法，而declare可以获取到除继承之外的所有方法，包括了private。在获取到方法之后，我们可以通过method.invoke来进行方法的调用（注意，对于private方法虽然可以获取到这个方法，但是不能直接使用，必须要设置setAccessble才行）

第三个，getField
Ans:该方法返回一个`Field`对象，这个方法需要一个参数即参数名。和declare的不同之处和上面第二个相似。我们获取到Field之后，可以通过`Field.get(实例)`来获取到这个实例的参数值。

第四个，setAccessable。
Ans:该方法用于修改属性的访问权限（可以这么认为，但实际上不是，这是开启或关闭安全检查的开关），可以将private变成可访问的。

第五个，method.invoke。这个方法需要两个参数，一个是拥有该方法的实例，一个是该方法的参数（无参可忽略）。拥有该方法的意思并不仅仅是指类A有一个方法getName，类B也有一个方法getName就可以了，我们通过输出方法的名字可以看到这两个方法不是同一个，因此可以认为我们通过getMethod获得的方法使用invoke时只能用于该类（或其子类）。

**4、反射有什么好处和缺点？**
好处：就我个人在项目中的使用情况而言，反射给我最大的好处就是可以写一些公用的封装接口，只要你给的实例具有这样的属性或者说能够这么操作，那么不管具体实现的属性名字是否相同、方法名是否相同，我都可以通过一个借口简单实现。
坏处：但是这样随之而来的问题也很麻烦，比如说我用了setAccessable来获取实例里面的属性，那么不可避免的我会把一些不该给用户看到的东西也全部拿出来，比如说文件存储地址啊什么的，这就是暴力破解带来的缺陷。而且错误只会在运行时发现，编译器不会发现这种错误。

**5、反射的例子**
可以用来遍历对象属性而不用在乎对象具体类型
可以不用迭代器模式而通过简单的循环来实现类似数组的遍历
可以利用反射绕过安全检查，提高代码效率


